<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gráfico de Pizza por equipment</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      .chart-container {
        width: 100%;
        max-width: 500px;
        margin: auto;
        padding-top: 20px;
        padding-bottom: 50px;
      }
      .chart-title {
        text-align: center;
        font-weight: bold;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div id="chart-container" class="col-12 chart-container">
          <!-- Gráfico será inserido aqui -->
        </div>
        <div id="table-container" class="activity-table mt-3 text-center">
          <!-- A tabela será inserida aqui -->
        </div>
      </div>
    </div>

    <script>
      function generateActivityTable(data) {
        const tableContainer = document.getElementById("table-container");

        // Limpa o conteúdo anterior
        tableContainer.innerHTML = "";

        // Cria o elemento da tabela
        const table = document.createElement("table");
        table.className = "table table-sm table-bordered";
        table.style.fontSize = "10px";

        // Cabeçalho da tabela
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        const activityHeader = document.createElement("th");
        activityHeader.innerText = "Atividade";
        activityHeader.style.fontSize = "10px";
        headerRow.appendChild(activityHeader);

        // Adiciona as colunas de etapas dinamicamente com base no número máximo de etapas em `data`
        const maxSteps = Math.max(
          ...data.map((activity) => activity.steps.length)
        );
        for (let i = 1; i <= maxSteps; i++) {
          const stepHeader = document.createElement("th");
          stepHeader.innerText = `Etapa ${i}`;
          stepHeader.style.fontSize = "10px";
          headerRow.appendChild(stepHeader);
        }

        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Corpo da tabela
        const tbody = document.createElement("tbody");

        data.forEach((activity) => {
          const row = document.createElement("tr");

          // Nome da atividade
          const activityName = document.createElement("td");
          activityName.innerText = activity.description;
          activityName.style.fontSize = "9px";
          row.appendChild(activityName);

          // Adiciona as etapas
          activity.steps.forEach((step) => {
            const stepCell = document.createElement("td");
            stepCell.innerText = step ? "✓" : "X";
            stepCell.style.fontSize = "9px";
            row.appendChild(stepCell);
          });

          // Preenche as células restantes para alinhar com o cabeçalho
          for (let i = activity.steps.length; i < maxSteps; i++) {
            const emptyCell = document.createElement("td");
            emptyCell.innerText = "";
            row.appendChild(emptyCell);
          }

          tbody.appendChild(row);
        });

        table.appendChild(tbody);
        tableContainer.appendChild(table);
      }

      const equipmanetName = "T-28D-11X";

      if (equipmanetName) {
        fetch(
          "https://raw.githubusercontent.com/lucassnts963/storage/refs/heads/master/acompanhamento/tanque/tanques.json"
        ) // Substitua pela URL pública do JSON
          .then((response) => response.json())
          .then((data) => {
            const equipmentData = data.find(
              (equip) => equip.equipment === equipmanetName
            );

            generateActivityTable(equipmentData.steps);

            if (equipmentData) {
              // Criação do gráfico de pizza para o equipment especificado
              const width = 300,
                height = 300,
                radius = Math.min(width, height) / 2;
              const chartContainer = d3.select("#chart-container");

              chartContainer
                .append("div")
                .attr("class", "chart-title")
                .text(equipmentData.equipment);

              const svg = chartContainer
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

              const pie = d3
                .pie()
                .value((d) => 1)
                .sort(null);
              const arc = d3.arc().outerRadius(radius).innerRadius(0);
              const filledArc = d3
                .arc()
                .outerRadius((d) => d.data.value * radius)
                .innerRadius(0);

              // Fatias vazias
              svg
                .selectAll("path.slice")
                .data(pie(equipmentData.data))
                .enter()
                .append("path")
                .attr("class", "slice")
                .attr("d", arc)
                .attr("fill", "lightgray")
                .attr("stroke", "white")
                .attr("stroke-width", 2);

              // Fatias preenchidas com animação
              svg
                .selectAll("path.filled-slice")
                .data(pie(equipmentData.data))
                .enter()
                .append("path")
                .attr("class", "filled-slice")
                .attr("fill", (d) => d.data.color)
                .attr("stroke", "white")
                .attr("stroke-width", 1.5)
                .transition()
                .duration(1000)
                .delay((_, i) => i * 100)
                .attrTween("d", function (d) {
                  const interpolateRadius = d3.interpolate(
                    0,
                    d.data.value * radius
                  );
                  return function (t) {
                    return d3
                      .arc()
                      .outerRadius(interpolateRadius(t))
                      .innerRadius(0)(d);
                  };
                });

              // Texto nas fatias
              svg
                .selectAll("text")
                .data(pie(equipmentData.data))
                .enter()
                .append("text")
                .attr("transform", (d) => `translate(${arc.centroid(d)})`)
                .text((d) => d.data.label)
                .attr("font-size", "12px")
                .attr("fill", "white")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "middle");
            } else {
              chartContainer.text("Equipamento não encontrado.");
            }
          })
          .catch((error) => {
            console.error("Erro ao carregar os data:", error);
          });
      } else {
        document.getElementById("chart-container").innerText =
          "Nenhum equipamento especificado.";
      }
    </script>
  </body>
</html>
